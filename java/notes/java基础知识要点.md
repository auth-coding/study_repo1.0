# summary for java

[TOC]


## 学习资料

### 视频
- [尚学堂java1000集](https://www.bilibili.com/video/av59676843?from=search&seid=621325440879512395)


## 学习感悟与笔记

### 基本数据类型

#### 数值类型

* java的常量用`final`修饰，并且遵循大写字母和下划线连接的命令规范；
* "string"，123，3.14等数据都是常量，并且有自己的数据类型，
但是这些常量一般只用于等号右边；123的默认类型是int(4bytes),
3.14默认是double;
* 123L指定常量为long类型，3.14f指定常量float类型；
* 当赋值运算符`=`两边的数据类型并不一样时，会触发自动`类型转换`，
但是只有低位向高位转换时能够自动转换，比如int转为long，float转为double；
> 可以想象赋值运算符左边为固定大小的容器，右边为固定大小的物体(值)，
int大小的物体能够装入long容器之中，却不能装入short容器，这就是自动类型转换；
而强制类型转换是将大的物体装入小的容器，必须强制截断，是有可能造成精度损失的。

#### 字符类型
* java中通过char声明字符类型，用单引号引起，如果使用unicode编码，
则每个字符占据两个字节，18位，能表示65536个字符。
* java中String 是引用类型，其内部实现是字符序列，使用双引号表示
字符串。


#### 布尔类型
* java中有`true`和`false`常量，只占用内存一位(不是一个字节)

### 运算符

#### 算术运算符

* +-/ % 属于二元运算符(左右各有一个操作数)
* `++`和`--`是一元运算符，也称为自增和自减运算符，并且java中自增运算区分放在操作数前和操作数后。

```java
int a = 0;
int b = 0;
b = ++a; // 先自增， ++a表达式的值为1，即a自增后的值， b的值也为1
a = 0, b = 0; // 将a,b的值置为0
b = a++ // 后自增， ++a的表达式的值为0，即a自增前的值，b的值也为0
```

#### 赋值运算符
> 赋值运算符没有特别需要注意的地方，但是常常涉及数据类型转换，
赋值运算符左边的数据类型(用以接受运算结果)表示范围必须比赋值结果大，
比如long可以接收int型值，float可以接收long型值。

#### 赋值扩展运算符

* +=
* -=
* *=
* /=

#### 比较运算符

* 比较运算符的返回结果为bool类型
* 比较运算符:`>=`,`<=`,`>`,`<`,`==`,`!=`

* 所有数据类型都支持`==`,`!=`运算符，包括基本数据类型和引用数据类型
* :`>=`,`<=`,`>`,`<`等数据类型仅仅适用于数值型数据类型

#### 逻辑运算符

* 逻辑与&，逻辑或|, 短路与&&, 短路或||, 逻辑非!, 逻辑异或^
* `异或`表示两个值(0-1或者true-false)比较，如果值相同，则结果为0，如果值不同则结果为1， 如果异或双方是数字，则会转换成二进制按位异或。

```java
true^false; // true
2^1; // 3 <==> 10^01
```

> 实际上，任何对数值进行的逻辑操作，都是将数值转换成二进制后再进行按位逻辑操作, 其实这里的逻辑运算符已经转变成了位运算符

* 短路操作实际的执行效率可能比逻辑操作更快，最终的执行结果是一致的。
* 逻辑非是一元运算符，即只对一个操作数进行操作。

#### 位运算符

* 取反~， 按位与&, 按位或|, 按位异或^,  左移<<, 右移>>

> 除了取反`~`与逻辑非不同`！`, 其他都和对应的逻辑运算符一致。

* 左移一位相当于*2， 右移一位相当于/2

> 如果对整数进行移位运算也只会得到整数，所以的这里的乘2，除2，都类似于python里的`Floor除法`

* 移位运算效率相当高，原码一般使用移位而不是乘除

#### 字符串连接符

* `+`一般作为数值的算术运算符，当`+`左右有任一操作数是字符串，+变成字符串连接符，表达式结果也是字符串。

> 运算符能作用于不同的数据类型，其实也是面向对象多态的体现

* 字符不同于字符串，每个字符都有自己对应的ASCII码值，当字符与数字作运算时，也可以看做数字。

#### 条件表达式

```java
x?y:z # 三目运算符
```

* 用于代替简单的`if else`

* x一般是最终结果为bool的表达式或者直接是布尔值，为`true`整个条件表达式返回y，为`false`表达式返回z。

> 与python不同, java中只有逻辑运算符和比较运算符会返回布尔值，数字和字符串的值不能用来指代true或者false。

### 类型转换

#### 自动类型转换

> 自动类型转换之前已经提到过，容量小的数据类型能够自动向容量大的数据类型转换。
>
> 数据类型的容量，即表示的数据范围，一般而言占用内存大的数据类型容量更大，但是并不绝对，比如`float`的容量要大于`long`的容量，因为`float`是表示的数据范围更大，可以表示的数更多，但同时浮点数也是不精确的。

数据在赋值给变量之前就有了自己的默认数据类型，比如整数的默认数据类型是`int`，浮点数的默认数据类型是`double`

```java
short a = 123; // 此时123的数据类型是int， 将123赋值给容量更小的short型变量a，是无法自动类型转换的，所以这是编译不通过的。
double b = 123; // 编译通过，有自动类型转换
long c = 123L; // 编译通过，指定123的数据类型是long, 赋值运算符左右变量是相同的数据类型， 建议使用大写L
int  d = 123L; // 编译无法通过，不能将long类型数据赋值给int
float e = 3.14; // 编译无法通过，3.14默认是double类型
float f = 3.14f; // 编译通过，特意声明3.14是float类型
```

#### 强制类型转换

* 强制类型转换也称为塑型，手动将将数据的类型转换成需要的数据类型
* 强制类型转换是通过截断二进制码的方式，可能造成精度的损失。

```java
int a = (int)3.14f;
```



#### 数据溢出

> 数据溢出是指变量得到一个超出数据类型范围的值，那么最终变量存储在内存里的值不是意想中的值。
>
> java语言是静态语言，存在编译检查，是不能将将大于数据类型范围的值赋值给变量的，
>
> 但是值得注意的是，得到运算结果发生在赋值前，运算结果的数据类型是表达式中值表达范围最大的数据类型。

```java
int a = 1e9 * 20; // 发生溢出， 10亿和20的数据类型都是int，所以运算表达式的值的数据类型也是int，但是10亿乘以20超出了int的数值范围(正负20亿左右)，所以会截断计算结果以能放进int的表达范围范围
long a = 1e9*20; // 同样发生截断，表达式结果仍然为int-->超出int表达范围-->截断--> 赋值给long类型变量，发生自动类型转换
```

### 流程控制



#### 顺序结构

> 一种自然而然的顺序 

#### 循环结构

>满足条件，继续执行
>
>for循环相对于while循环，for循环的结构更为紧密通用，赋值，判断，步值迭代都在一个for循环体内

####  选择结构

> 如果...则...；if...else...

* `if `单选择结构
* `if-else`双选择结构
* `if-else if-else` 多选择结构
* `switch`结构

> switch也是一种多选择结构，区别在switch一般用于多值的条件判断;
>
> switch必须要有break， 执行匹配的对应代码块后会继续执行，直到遇到break为止；
>
> switch和case标准写法为同一缩进(`java不强制要求缩进`)